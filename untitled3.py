# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lhM0-lmu9-_dswkQG7TBkDJYo8ResWWJ

2. Chat with Website Using RAG Pipeline
"""

!pip install requests beautifulsoup4 sentence-transformers faiss-cpu

import requests
import hashlib
import hmac
import json
from bs4 import BeautifulSoup
from sentence_transformers import SentenceTransformer
import faiss

# Gemini API Key Setup
GEMINI_API_KEY = "AIzaSyBq3nsMVcC6eQPjeYURI3nCDrHKOADLeY0" #Use your own API

# Gemini API Authentication
def authenticate_gemini():
    headers = {
        "Content-Type": "application/json",
        "X-GEMINI-APIKEY": GEMINI_API_KEY,
    }
    response = requests.get("https://api.gemini.com/v1/pubticker/btcusd", headers=headers)
    if response.status_code == 200:
        print("Authenticated successfully with Gemini API!")
    else:
        raise Exception(f"Authentication failed: {response.json()}")

# Scrape website using requests
def scrape_website(url):
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    }
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        soup = BeautifulSoup(response.text, "html.parser")
        paragraphs = soup.find_all("p")
        text = " ".join([para.get_text() for para in paragraphs])
        return text
    else:
        raise Exception(f"Failed to fetch {url}: {response.status_code}")

# Scrape website using Selenium for JavaScript-rendered content
def scrape_website_with_selenium(url):
    options = Options()
    options.add_argument("--headless")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    service = Service("/usr/bin/chromedriver")
    driver = webdriver.Chrome(service=service, options=options)
    driver.get(url)
    soup = BeautifulSoup(driver.page_source, "html.parser")
    paragraphs = soup.find_all("p")
    text = " ".join([para.get_text() for para in paragraphs])
    driver.quit()
    return text

# Chunking the text
def chunk_text(text, chunk_size=300):
    words = text.split()
    return [' '.join(words[i:i+chunk_size]) for i in range(0, len(words), chunk_size)]

# Embedding and storing in FAISS
model = SentenceTransformer('all-MiniLM-L6-v2')

def embed_and_store(chunks):
    embeddings = model.encode(chunks)
    dimension = embeddings.shape[1]
    vector_db = faiss.IndexFlatL2(dimension)
    vector_db.add(embeddings)
    return vector_db, embeddings

# Query Handling
def query_vector_search(query, vector_db, chunks, top_k=5):
    query_vec = model.encode([query])
    distances, indices = vector_db.search(query_vec, top_k)
    results = [chunks[i] for i in indices[0]]
    return results

# Generate a simple response
def generate_response(query, context):
    response = f"Query: {query}\n\nRelevant Context:\n{context}"
    return response

# Complete Workflow
try:
    # Authenticate with Gemini
    authenticate_gemini()

    # List of URLs to scrape
    urls = [
        "https://www.uchicago.edu/",
        "https://www.washington.edu/",
        "https://www.stanford.edu/",
        "https://und.edu/"
    ]

    # Scrape content from websites
    all_chunks = []
    for url in urls:
        try:
            print(f"Scraping: {url}")
            website_text = scrape_website(url)
        except Exception as e:
            print(f"Using Selenium for: {url}")
            website_text = scrape_website_with_selenium(url)
        chunks = chunk_text(website_text)
        all_chunks.extend(chunks)

    # Store embeddings in FAISS
    vector_db, embeddings = embed_and_store(all_chunks)
    # Query the system
    query = "What are the main features of Stanford University?"
    retrieved_chunks = query_vector_search(query, vector_db, all_chunks)
    context = "\n".join(retrieved_chunks)

    # Generate response
    response = generate_response(query, context)
    print("\nResponse:")
    print(response)

except Exception as e:
    print("Error occurred:", e)